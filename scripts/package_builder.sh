#!/usr/bin/env bash

# package_builder.sh — 通用 DEB 打包脚本

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
WS_DIR="$(dirname "$SCRIPT_DIR")"
source "${WS_DIR}/scripts/function.bash"
set_error_handling

print_help() {
  printf '%s\n' \
    'DEB 打包脚本 (通用)' \
    '' \
    '必填参数:' \
    '  --name <string>      Debian 包名 (小写字母、数字、连字符)' \
    '  --version <string>   包版本号 (如 1.0.0)' \
    '  --prefix <path>      安装前缀 (绝对路径, 不能为 /)' \
    '  --source <path>      要打包的源目录' \
    '' \
    '可选参数:' \
    '  --arch <string>      目标架构 (默认: dpkg --print-architecture)' \
    '  --output <path>      输出目录 (默认: 当前目录)' \
    '  --keep-staging       保留临时构建目录' \
    '  --verbose            输出详细执行日志' \
    '  -h, --help           显示本帮助' \
    '' \
    '示例:' \
    '  ./scripts/package_builder.sh --name pkg_name --version pkg_version --prefix /usr/local --source pkg_source' \
    ''
}

# 参数初始化
PACKAGE_NAME=""
PACKAGE_VERSION=""
ARCH=""
INSTALL_PREFIX=""
SOURCE_PATH=""
OUTPUT_DIR="$PWD"
KEEP_STAGING=false
VERBOSE=false

# 解析参数
while [[ $# -gt 0 ]]; do
  case "$1" in
    --name)
      PACKAGE_NAME="${2:-}"
      shift 2;;
    --version)
      PACKAGE_VERSION="${2:-}"
      shift 2;;
    --arch)
      ARCH="${2:-}"
      shift 2;;
    --prefix)
      INSTALL_PREFIX="${2:-}"
      shift 2;;
    --source)
      SOURCE_PATH="${2:-}"
      shift 2;;
    --output)
      OUTPUT_DIR="${2:-}"
      shift 2;;
    --keep-staging)
      KEEP_STAGING=true
      shift;;
    --verbose)
      VERBOSE=true
      shift;;
    -h|--help)
      print_help
      safe_exit 0;;
    *)
      log_error "未知参数: $1"
      print_help
      safe_exit 1;;
  esac
done

[[ "$VERBOSE" == true ]] && set -x

# 校验必填参数（缺失或空值都视为错误）
missing_args=()
[[ -z "$PACKAGE_NAME" ]] && missing_args+=("--name")
[[ -z "$PACKAGE_VERSION" ]] && missing_args+=("--version")
[[ -z "$INSTALL_PREFIX" ]] && missing_args+=("--prefix")
[[ -z "$SOURCE_PATH" ]] && missing_args+=("--source")
if [[ ${#missing_args[@]} -gt 0 ]]; then
  log_error "缺少必填参数: ${missing_args[*]}"
  print_help
  safe_exit 1
fi

# 进一步格式校验
if [[ "$PACKAGE_NAME" != "${PACKAGE_NAME,,}" || ! "$PACKAGE_NAME" =~ ^[a-z0-9][a-z0-9-]*$ ]]; then
  log_error "包名必须为小写字母、数字或连字符: $PACKAGE_NAME"
  print_help; safe_exit 1
fi
if [[ ! "$PACKAGE_VERSION" =~ ^[0-9A-Za-z.+~-]+$ ]]; then
  log_error "版本号格式不合法: $PACKAGE_VERSION"
  print_help; safe_exit 1
fi
if [[ "${INSTALL_PREFIX:0:1}" != "/" || "$INSTALL_PREFIX" == "/" ]]; then
  log_error "安装前缀必须为绝对路径且不能为根目录: $INSTALL_PREFIX"
  print_help; safe_exit 1
fi

# 路径解析
resolve_path() {
  local p="$1"
  if [[ -z "$p" ]]; then return 1; fi
  if [[ "$p" == /* ]]; then
    readlink -f "$p"
  else
    readlink -f "$PWD/$p"
  fi
}

SOURCE_DIR=$(resolve_path "$SOURCE_PATH") || { log_error "无法解析源目录: $SOURCE_PATH"; safe_exit 1; }
if [[ ! -d "$SOURCE_DIR" ]]; then
  log_error "源目录不存在: $SOURCE_DIR"; safe_exit 1
fi

if [[ -z "$OUTPUT_DIR" ]]; then OUTPUT_DIR="$PWD"; fi
OUTPUT_DIR=$(resolve_path "$OUTPUT_DIR") || { log_error "无法解析输出目录"; safe_exit 1; }

# 自动检测架构
if [[ -z "$ARCH" ]]; then
  if ! ARCH=$(dpkg --print-architecture 2>/dev/null); then
    log_error "无法自动检测架构，请使用 --arch 指定"
    safe_exit 1
  fi
fi

# 依赖检查
REQUIRED=(dpkg-deb fakeroot du)
if command -v rsync >/dev/null 2>&1; then
  USE_RSYNC=true
else
  USE_RSYNC=false
  REQUIRED+=(cp)
fi
MISSING=0
for c in "${REQUIRED[@]}"; do
  if ! command -v "$c" >/dev/null 2>&1; then
    log_error "缺少命令: $c"; MISSING=1
  fi
done
if [[ $MISSING -ne 0 ]]; then
  print_help; safe_exit 1
fi

# 构建布局
BUILD_ROOT="$WS_DIR/build/pkg"
STAGING_ROOT="$BUILD_ROOT/${PACKAGE_NAME}_${PACKAGE_VERSION}"
PAYLOAD_ROOT="${STAGING_ROOT}${INSTALL_PREFIX}"
DEBIAN_DIR="$STAGING_ROOT/DEBIAN"

log_info "准备临时构建目录: $STAGING_ROOT"
rm -rf "$STAGING_ROOT"
mkdir -p "$PAYLOAD_ROOT" "$DEBIAN_DIR"

log_info "复制文件: 仅拷贝顶层标准目录 bin/include/lib/share"
COPIED_COUNT=0
WHITELIST=(bin include lib share)
for d in "${WHITELIST[@]}"; do
  if [[ -e "$SOURCE_DIR/$d" ]]; then
    log_info "-> 拷贝 $d/"
    if [[ "$USE_RSYNC" == true ]]; then
      rsync -a "$SOURCE_DIR/$d" "$PAYLOAD_ROOT/"
    else
      cp -a "$SOURCE_DIR/$d" "$PAYLOAD_ROOT/"
    fi
    COPIED_COUNT=$((COPIED_COUNT+1))
  fi
done

if [[ $COPIED_COUNT -eq 0 ]]; then
  log_error "源目录未包含可识别的顶层目录：bin/ include/ lib/ share/"
  safe_exit 1
fi

INSTALLED_SIZE=$(du -sk "$PAYLOAD_ROOT" 2>/dev/null | awk '{print $1}')
INSTALLED_SIZE=${INSTALLED_SIZE:-0}

cat > "$DEBIAN_DIR/control" <<EOF
Package: $PACKAGE_NAME
Version: $PACKAGE_VERSION
Section: misc
Priority: optional
Architecture: $ARCH
Maintainer: unknown <noreply@example.com>
Description: Generated by package_builder.sh
Installed-Size: $INSTALLED_SIZE
EOF

log_info "构建 DEB 包"
TMP_DEB="$BUILD_ROOT/${PACKAGE_NAME}_${PACKAGE_VERSION}_${ARCH}.deb"
fakeroot dpkg-deb --build "$STAGING_ROOT" "$TMP_DEB"

mkdir -p "$OUTPUT_DIR"
FINAL_DEB="$OUTPUT_DIR/$(basename "$TMP_DEB")"
log_info "移动包到输出目录: $FINAL_DEB"
mv -f "$TMP_DEB" "$FINAL_DEB"

if [[ "$KEEP_STAGING" == false ]]; then
  rm -rf "$STAGING_ROOT"
else
  log_info "保留临时目录: $STAGING_ROOT"
fi

safe_exit 0 "DEB 打包完成：$FINAL_DEB"
